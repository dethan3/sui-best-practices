#  `entry` 和 `public` 使用详解

## 引言

Sui 区块链作为一款高性能的 Layer 1 公链，其智能合约开发主要依赖 Move 编程语言。Move 是一种资源导向的语言，强调安全性和所有权模型，避免了传统智能合约常见的漏洞如重入攻击和整数溢出。在 Move 中，函数的可见性和调用方式由特定的修饰符控制，其中 `public` 和 `entry` 是两个核心概念。它们决定了函数在模块间、包间以及交易块（Transaction Block）中的可访问性。

简单来说，`public` 控制函数的**跨模块可见性**，允许其他合约复用你的逻辑；`entry` 则定义**交易入口点**，确保函数能直接从链上交易调用，而不受其他 Move 逻辑的干扰。这两个修饰符的选择直接影响合约的安全性、模块化设计和用户交互体验。本文将详细探讨何时使用 `entry` 和 `public`，结合官方文档和示例，提供全面指南，帮助开发者在 Sui 生态中构建可靠的 dApp。

## `public` 修饰符：跨模块复用与可见性控制

### 定义与基本机制
`public` 是 Move 中最常见的可见性修饰符，它使函数在**任何模块或包中可见和可调用**。默认情况下，Move 函数是 `internal`（内部可见，仅限本模块），添加 `public` 后，函数即可被外部合约导入并执行。这类似于传统编程语言中的“公开方法”，促进代码复用和生态协作。

在 Sui 中，`public` 函数可以作为 Programmable Transaction Blocks (PTB) 中的 MoveCall 的一部分，但不能直接作为交易入口。它支持灵活的参数传递，包括值、不可变引用（`&`）和可变引用（`&mut`），返回类型也无严格限制。

### 何时使用 `public`
使用 `public` 的核心场景是当你的函数需要**被其他模块或包复用**，而非直接暴露给用户交易时。以下是典型时机：

1. **库函数或工具模块**：如果你开发一个通用计算库（如数学运算或字符串处理），`public` 允许其他合约调用这些辅助函数，而无需复制代码。
   - 示例：一个 DeFi 协议的利率计算模块，可以将 `calculate_interest` 函数标记为 `public`，让借贷合约和流动性池合约共享。

2. **模块间协作**：在多模块包中，`public` 确保核心逻辑可被子模块访问，但不暴露给外部包。
   - 变体：使用 `public(package)` 限制仅在同一包内可见，增强封装性（适用于大型项目）。

3. **非入口点逻辑**：当函数是合约内部的“工作马”，需被其他 `entry` 函数调用时，使用 `public` 便于集成。

避免使用 `public` 的情况：如果函数涉及敏感操作（如资金转移），直接标记 `public` 可能导致未授权访问。应结合权限检查（如签名验证）。

### 示例代码
以下是一个简单的 `public` 函数示例，来自 Move 官方参考：

```move
module example::math {
    /// 计算两个 u64 的和
    public fun add(a: u64, b: u64): u64 {
        a + b
    }
}

module example::calculator {
    use example::math;
    
    /// 使用 math::add 进行计算
    public fun calculate_total(x: u64, y: u64): u64 {
        math::add(x, y)
    }
}
```

在这里，`add` 函数是 `public`，允许 `calculator` 模块调用它。如果没有 `public`，调用将失败。

### 最佳实践
- **权限结合**：总是添加访问控制，如检查调用者地址。
- **避免过度暴露**：优先使用 `public(package)` 限制范围。
- **测试**：在 `#[test]` 中验证跨模块调用。

## `entry` 修饰符：交易入口与安全隔离

### 定义与基本机制
`entry` 是 Sui Move 的专有修饰符（Move 标准中也支持，但 Sui 有特定规则），它将函数标记为**交易的直接入口点**。这意味着函数可从 PTB 直接调用，而无需被其他 Move 逻辑包裹。默认 `entry` 函数是内部可见的（不加 `public`），强调隔离执行。

Sui 的设计中，`entry` 函数有严格限制：
- 参数：仅支持对象引用（`&Object` 或 `&mut Object`），不能是纯值（如 u64，除非通过对象包装）。
- 返回：仅支持具有 `drop` 能力的类型（如 u64、bool），不能是复杂结构体。
- PTB 规则：在同一交易块中，`entry` 函数不能与非 `entry` 函数共享输入对象，防止前跑/后跑攻击。

这些限制确保了原子性和安全性，尤其适用于高风险操作。

### 何时使用 `entry`
`entry` 适用于**用户直接交互的入口函数**，强调直接链上调用和隔离执行。典型时机包括：

1. **用户操作入口**：如 mint NFT、转账代币或 stake 资产。这些函数应直接响应钱包交易，而非被其他合约间接调用。
   - 示例：Sui 的 on-chain 随机数生成标准使用 `entry` 防止其他合约插队操纵结果。

2. **防止攻击向量**：当函数涉及随机性、拍卖或奖励发放时，`entry` 隔离执行，避免重排序攻击。
   - 场景：一个游戏合约的“抽奖”函数，使用 `entry` 确保用户交易原子执行。

3. **模块主函数**：定义模块的“起点”，如初始化或核心业务逻辑，但无需跨模块暴露。

避免使用 `entry` 的情况：如果函数是纯计算或需被多次复用，应选 `public` 而非 `entry`。

### 示例代码
Sui 官方文档中的 `entry` 示例：

```move
module example::nft {
    use sui::object::{Self, UID};
    use sui::tx_context::{Self, TxContext};
    use sui::transfer;

    struct NFT has key, store {
        id: UID,
    }

    /// 直接 mint NFT 的入口函数
    entry fun mint_nft(ctx: &mut TxContext) {
        let nft = NFT { id: object::new(ctx) };
        transfer::public_transfer(nft, tx_context::sender(ctx));
    }
}
```

此函数可直接通过 Sui CLI 调用：`sui client call --package <pkg> --module nft --function mint_nft`。如果加 `public`，它仍可跨模块调用，但官方推荐不加以保持私有性。

### 最佳实践
- **保持私有**：通常不加 `public`，仅用 `entry` 确保隔离。
- **参数优化**：使用 TxContext 处理发送者信息。
- **测试**：`entry` 函数易于在测试中直接调用，便于验证。

## `entry` 与 `public` 的区别、结合与选择指南

### 核心区别
| 方面       | `public`                          | `entry`                           |
|------------|-----------------------------------|-----------------------------------|
| **可见性** | 跨模块/包可见                     | 默认内部（可加 `public` 扩展）    |
| **调用方式** | 通过 MoveCall 包装（PTB 中间接） | 直接从 PTB 调用，无需包装         |
| **参数/返回** | 灵活（值、引用、复杂类型）        | 严格（对象引用；drop 类型返回）   |
| **安全焦点** | 复用与协作                        | 隔离与原子性（防前跑）            |
| **典型场景** | 库函数、内部工具                  | 用户入口、随机生成                |

- **区别总结**：`public` 强调“共享”，`entry` 强调“直接且安全”。`public` 适合构建生态，`entry` 适合用户交互。

### 结合使用：`public entry`
在需要**既跨模块可见又作为入口**时，可结合：`public entry fun ...`。例如，一个公共 API 的转账函数，既允许其他合约调用，也支持直接交易。但在 Sui 中，此组合较少用，因为 `entry` 通常优先隔离。

### 选择指南
- **优先 `public`**：需复用逻辑？选它。
- **优先 `entry`**：用户直接调用？选它。
- **评估风险**：敏感操作用 `entry` + 权限检查。
- **Sui 特有**：参考对象模型，确保参数符合规则。

## 最佳实践与注意事项

1. **安全审计**：`public` 函数易暴露漏洞，结合 Move 的资源能力（如 `key`、`store`）验证所有权。
2. **Gas 优化**：`entry` 函数因隔离，可能 gas 更高；测试 PTB 组合。
3. **升级兼容**：函数签名变更需谨慎，影响调用方。
4. **工具支持**：用 Sui CLI 测试调用；Move Prover 验证逻辑。
5. **常见陷阱**：忘记 `drop` 返回导致编译失败；共享对象时忽略 `entry` 隔离。
